//
//  main.c
//  约瑟夫环
//
//  Created by Qinting on 2016/12/16.
//  Copyright © 2016年 QT. All rights reserved.
//

#include <stdio.h>
#include "JoseCircleList.h"

/** 
 约瑟夫环问题（C语言、数据结构版）
 一、问题描述
 N个人围城一桌（首位相连），约定从1报数，报到数为k的人出局，然后下一位又从1开始报，以此类推。最后留下的人获胜。（有很多类似问题，如猴子选代王等等，解法都一样）
 二、思路分析
 （1）可将人的顺序简单编号，从1到N；
 （2）构造一个循环链表，可以解决首位相连的问题，同时如果将人的编号改为人名或者其他比较方便
 （3）将人的编号插入到结构体的Data域；
 （4）遍历人的编号，输出参与的人的编号；
 （5）开始报数，从头报数，报到k的人出局（删除次结点），（输出出局的人更人性化）避免浪费，可释放次结点。直到人数只有一个人时，退出循环。输出获胜的人。
 （6）注意：在写删除删除结点的函数时都是针对K>=2的情况处理，所以要考虑k=1的情况，要是出局的密码为1时则最后一个获胜。
 */

/***************************************/
 int main()
 {
        int i;//计数器
        int N;//参与的人数
        int k;//报数密码
        printf("请输入参与人数：");
        scanf("%d",&N);
        printf("请输入出局密码：");
        scanf("%d",&k);
    
    /**************得到头结点****************/
        HeadNode h = ((HeadNode)malloc(sizeof(JoseNode)));
    
    /***************初始化单链表************/
         JoseInit(&h);
    
     /******将编号插入到循环单链表中******/
         for (i = 1; i <=N; i++)
             {
                     JoseInsert(h, i, i);
            }
     /**************遍历单链表***************/
         TraverseList(h,N);
    
     /***************出局函数************/
         if(k > 1)
             JoseDelete(h, N, k);
         else
          {
            for(i = 1; i < N; i++)
            printf("出局的人为：%d号\n",i);
            printf("***************获胜者为：%d号***************",N);
          }
     
         printf("\n");
         printf("\n");
         return 0;
     }
